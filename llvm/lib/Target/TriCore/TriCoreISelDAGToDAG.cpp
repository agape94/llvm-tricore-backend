//===-- TriCoreISelDAGToDAG.cpp - A dag to dag inst selector for TriCore ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the TriCore target.
//
//===----------------------------------------------------------------------===//

#include "TriCoreAluCode.h"
#include "TriCoreMachineFunctionInfo.h"
#include "TriCoreRegisterInfo.h"
#include "TriCoreSubtarget.h"
#include "TriCoreTargetMachine.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetMachine.h"
#include <iostream>

using namespace llvm;

#define DEBUG_TYPE "tricore-isel"
#define PASS_NAME "TriCore DAG->DAG Pattern Instruction Selection"

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// TriCoreDAGToDAGISel - TriCore specific code to select TriCore machine
// instructions for SelectionDAG operations.
//===----------------------------------------------------------------------===//
namespace {
struct TriCoreISelAddressMode {
  enum {
    RegBase,
    FrameIndexBase
  } BaseType;

  struct {            // This is really a union, discriminated by BaseType!
    SDValue Reg;
    int FrameIndex;
  } Base;

  int64_t Disp;
  const GlobalValue *GV;
  const Constant *CP;
  const BlockAddress *BlockAddr;
  const char *ES;
  int JT;
  unsigned Align;    // CP alignment.

  TriCoreISelAddressMode()
  : BaseType(RegBase), Disp(0), GV(nullptr), CP(nullptr),
    BlockAddr(nullptr), ES(nullptr), JT(-1), Align(0) {
  }

  bool hasSymbolicDisplacement() const {
    return GV != nullptr || CP != nullptr || ES != nullptr || JT != -1;
  }

  // void dump() {
  //   errs() << "rriCoreISelAddressMode " << this << '\n';
  //   if (BaseType == RegBase && Base.Reg.getNode() != nullptr) {
  //     errs() << "Base.Reg ";
  //     Base.Reg.getNode()->dump();
  //   } else if (BaseType == FrameIndexBase) {
  //     errs() << " Base.FrameIndex " << Base.FrameIndex << '\n';
  //   }
  //   errs() << " Disp " << Disp << '\n';
  //   if (GV) {
  //     errs() << "GV ";
  //     GV->dump();
  //   } else if (CP) {
  //     errs() << " CP ";
  //     CP->dump();
  //     errs() << " Align" << Align << '\n';
  //   } else if (ES) {
  //     errs() << "ES ";
  //     errs() << ES << '\n';
  //   } else if (JT != -1)
  //     errs() << " JT" << JT << " Align" << Align << '\n';
  // }
};
class TriCoreDAGToDAGISel : public SelectionDAGISel {
public:
  static char ID;

  TriCoreDAGToDAGISel() = delete;

  explicit TriCoreDAGToDAGISel(TriCoreTargetMachine &TargetMachine)
      : SelectionDAGISel(ID, TargetMachine) {}

  /// getI32Imm - Return a target constant with the specified value, of type
  /// i32.
  inline SDValue getI32Imm(unsigned Imm, const SDLoc &dl) {
    return CurDAG->getTargetConstant(Imm, dl, MVT::i32);
  }
  
  /// getI16Imm - Return a target constant with the specified value, of type
  /// i16.
  inline SDValue getI16Imm(unsigned Imm, const SDLoc &dl) {
    return CurDAG->getTargetConstant(Imm, dl, MVT::i16);
  }
  static bool ptyType;
  static bool isPointer();
  bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool MatchAddress(SDValue N, TriCoreISelAddressMode &AM);
  bool MatchWrapper(SDValue N, TriCoreISelAddressMode &AM);
  bool MatchAddressBase(SDValue N, TriCoreISelAddressMode &AM);

private:
// Include the pieces autogenerated from the target description.
#include "TriCoreGenDAGISel.inc"

  // Instruction Selection not handled by the auto-generated tablgen
  void Select(SDNode *N) override;
 void SelectConstant(SDNode *N);
};

} // namespace

char TriCoreDAGToDAGISel::ID = 0;

INITIALIZE_PASS(TriCoreDAGToDAGISel, DEBUG_TYPE, PASS_NAME, false, false)

// Select instructions not customized! Used for
// expanded, promoted and normal instructions
void TriCoreDAGToDAGISel::Select(SDNode *Node) {
  SDLoc dl(Node);
  switch (Node->getOpcode()) {
    case ISD::Constant:
      SelectConstant(Node);
      return;
    case ISD::FrameIndex: {
      int FI = cast<FrameIndexSDNode>(Node)->getIndex();
      SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i32);
      if (Node->hasOneUse()) {
        CurDAG->SelectNodeTo(Node, TRICORE::ADDrc, MVT::i32, TFI, CurDAG->getTargetConstant(0, dl, MVT::i32));
            
            return;
      }
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::ADDrc, dl, MVT::i32, TFI,
          CurDAG->getTargetConstant(0, dl, MVT::i32)));

          return;
    }
    case ISD::STORE: {
      ptyType = Node->getOperand(1).getValueType() == MVT::iPTR;
      break;
    }
  }
  SelectCode(Node);
}

bool TriCoreDAGToDAGISel::ptyType = false;
bool TriCoreDAGToDAGISel::isPointer() { return ptyType; }

bool TriCoreDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset)
{
  TriCoreISelAddressMode AM;

  // DEBUG( errs().changeColor(raw_ostream::YELLOW,1);
  // Addr.dump();

  if (MatchAddress(Addr, AM))
    return false;

  EVT VT = Addr.getValueType();
  if (AM.BaseType == TriCoreISelAddressMode::RegBase) {
    // DEBUG(errs() << "It's a reg base";);
    if (!AM.Base.Reg.getNode())
      AM.Base.Reg = CurDAG->getRegister(0, VT);
  }


  Base = (AM.BaseType == TriCoreISelAddressMode::FrameIndexBase)
                 ? CurDAG->getTargetFrameIndex(
                     AM.Base.FrameIndex,
                     getTargetLowering()->getPointerTy(CurDAG->getDataLayout()))
                     : AM.Base.Reg;

  if (AM.GV) {
    // DEBUG(errs() <<"AM.GV" );
    //GlobalAddressSDNode *gAdd = dyn_cast<GlobalAddressSDNode>(N.getOperand(0));
    Base = Addr;
    Offset = CurDAG->getTargetConstant(AM.Disp, Addr, MVT::i32);
  }
  else {
    // DEBUG(errs()<<"SelectAddr -> AM.Disp\n";
    // errs()<< "SelectAddr -> Displacement: " << AM.Disp; );
    Offset = CurDAG->getTargetConstant(AM.Disp, SDLoc(Addr), MVT::i32);
  }

  return true;
}

FunctionPass *llvm::createTriCoreISelDag(TriCoreTargetMachine &TM) {
  return new TriCoreDAGToDAGISel(TM);
}

// Returns one plus the index of the least significant
// 1-bit of x, or if x is zero, returns zero.
static int getFFS (unsigned v) { return __builtin_ffs(v);}

// Return the number of set bits
static int getNumSetBits(unsigned int v) {
  int c=0;
  v = v - ((v >> 1) & 0x55555555);                    // reuse input as temporary
  v = (v & 0x33333333) + ((v >> 2) & 0x33333333);     // temp
  c = (((v + (v >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24; // count
  return c;
}

// Return the number of consecutive set bits
static int getNumConsecutiveOnes(int in) {
  int count = 0;
  while (in) {
    in = (in & (in << 1));
    count++;
  }
  return count;
}

static int ipow(int base)
{
    int result = 1;
    for (int i = 0; i<base; i++)
      result = result<<1;
    return result;
}

void TriCoreDAGToDAGISel::SelectConstant(SDNode *Node) 
{
  // Make sure the immediate size is supported.
  ConstantSDNode *ConstVal = cast<ConstantSDNode>(Node);
  uint64_t ImmVal = ConstVal->getZExtValue();
  int64_t ImmSVal = ConstVal->getSExtValue();

  if ( ConstVal->getValueType(0) == MVT::i64) {
    /*
      * In case, we get a 64 bit constant node, we first try to generate an
      * imask instruction. Only if it fails, then we proceed to generate
      * pseudo moves.
      */
    uint32_t lowerByte  = ImmVal & 0x00000000ffffffff;
    uint32_t higherByte = ImmVal>>32;
    uint64_t width = 0;

    outs()<<"higherByte: " << higherByte << "\n";
    outs()<<"lowerByte: " <<  lowerByte << "\n";
    if (ImmVal == 0) {
      SDValue _constVal = CurDAG->getTargetConstant(0, Node, MVT::i32);
      SDValue _width = CurDAG->getTargetConstant(0, Node, MVT::i32);
      SDValue _pos = CurDAG->getTargetConstant(0, Node, MVT::i32);
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::IMASKrcpw, Node, MVT::i64,
                  _constVal, _pos, _width));
      return;
    }

    // In case both bytes contain set bits then exit
    if(ImmSVal<0 || (higherByte!=0 && lowerByte!=0)) {
      outs()<< "exit\n";
      SelectCode(Node);
      return;
    }
    else if(higherByte==0 && lowerByte!=0) {
      uint64_t posLSB = getFFS(lowerByte) - 1;
      uint64_t numSetBits = getNumSetBits(lowerByte);
      uint64_t numConsecBits = getNumConsecutiveOnes(lowerByte);
      // In case the patch of set bits is not a mask then exit
      if (numSetBits != numConsecBits) 
      {
        SelectCode(Node);
      } 

      // In case the mask for the lower byte is > 0xf we exit
      if (numConsecBits > 4) 
      {
        SelectCode(Node);
      }

      // In case we are dealing with the lower byte,
      // only Const4Val is set
      int64_t Const4Val = ipow(numConsecBits) - 1;
      outs()<<"posLSB: " << posLSB << "\n";
      outs()<<"ConstVal: " << Const4Val << "\n";

      SDValue _constVal = CurDAG->getTargetConstant(Const4Val, Node, MVT::i32);
      SDValue _width = CurDAG->getTargetConstant(width, Node, MVT::i32);
      SDValue _pos = CurDAG->getTargetConstant(posLSB, Node, MVT::i32);

      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::IMASKrcpw, Node, MVT::i64,
          _constVal, _pos, _width));
      return;
    }
    else if (higherByte!=0 && lowerByte==0) {
      uint64_t posLSB = getFFS(higherByte) - 1;
      uint64_t numSetBits = getNumSetBits(higherByte);
      uint64_t numConsecBits = getNumConsecutiveOnes(higherByte);
      outs()<<"posLSB: " << posLSB << "\n";
      outs()<<"numConsecBits: " << numConsecBits << "\n";
      // In case the patch of set bits is not a mask then exit
      if (numSetBits != numConsecBits) 
      {
        SelectCode(Node);
      }

      // As per data sheet: (pos  + width)>31 is undefined
      if ((posLSB + numConsecBits) > 31) 
      {
        SelectCode(Node);
      }

      SDValue _constVal = CurDAG->getTargetConstant(0, Node, MVT::i32);
      SDValue _width = CurDAG->getTargetConstant(numConsecBits, Node, MVT::i32);
      SDValue _pos = CurDAG->getTargetConstant(posLSB, Node, MVT::i32);

      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::IMASKrcpw, Node, MVT::i64,
          _constVal, _pos, _width));
      return;
    }
  }
//    if ((ImmVal & SupportedMask) != ImmVal) {
////      outs() <<" Immediate size not supported!\n";
//      return SelectCode(N);
//    }

  // Select the low part of the immediate move.
  uint64_t LoMask = 0xffff;
  uint64_t HiMask = 0xffff0000;
  uint64_t ImmLo = (ImmVal & LoMask);
  int64_t ImmSLo = (ImmSVal & LoMask) - 65536;

//    outs() << "SLo: " << ImmSLo << "\n";
  uint64_t ImmHi = (ImmVal & HiMask);
  SDValue ConstLo = CurDAG->getTargetConstant(ImmLo, Node, MVT::i32);
  SDValue ConstSImm = CurDAG->getTargetConstant(ImmSVal, Node, MVT::i32);
  SDValue ConstEImm = CurDAG->getTargetConstant(ImmVal, Node, MVT::i32);
  SDValue ConstHi;

  int64_t ImmLo_ext64 = (int16_t)ImmLo;
  int64_t hiShift = (ImmSVal - ImmLo_ext64) >> 16;

  if (hiShift < 0)
    hiShift = 65536 + hiShift;

  ConstHi = CurDAG->getTargetConstant(hiShift, Node, MVT::i32);


  if ((ImmHi == 0) && ImmLo) {
    if (ImmSVal >=0 && ImmSVal < 32768)
    {
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::MOVrlc, Node, MVT::i32, ConstEImm));
      return;
    }
    else if(ImmSVal >=32768 && ImmSVal < 65536)
    {
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::MOV_Urlc, Node, MVT::i32, ConstEImm));
      return;
    }
  }
  else if(ImmHi && (ImmLo == 0))
  {
    CurDAG->getMachineNode(TRICORE::MOVHrlc, Node, MVT::i32, ConstHi);
    return;
  }
  else if((ImmHi == 0) && (ImmLo == 0))
  {
    ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::MOVrlc, Node, MVT::i32, ConstHi));
    return;
  }
  else {
    if ( (ImmSVal >= -32768) && (ImmSVal < 0))
    {
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::MOVrlc, Node, MVT::i32, ConstSImm));
      return;
    }
    MachineSDNode *Move = CurDAG->getMachineNode(TRICORE::MOVHrlc, Node, MVT::i32, ConstHi);

    if( (ImmSLo >= -8 && ImmSLo < 8 ) || ImmLo < 8)
    {
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::ADDsrc, Node, MVT::i32, SDValue(Move,0), ConstLo));
      return;
    }
    else if(ImmLo >=8 && ImmLo < 256)
    {
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::ADDrc, Node, MVT::i32, SDValue(Move,0), ConstLo));
      return;
    }
    else
    {
      ReplaceNode(Node, CurDAG->getMachineNode(TRICORE::ADDIrlc, Node, MVT::i32, SDValue(Move,0), ConstLo));
      return;
    }
  }
}
bool TriCoreDAGToDAGISel::MatchAddress(SDValue N, TriCoreISelAddressMode &AM) {
  switch (N.getOpcode()) {
  default: break;
  case ISD::Constant: {

    uint64_t Val = cast<ConstantSDNode>(N)->getSExtValue();
    AM.Disp += Val;
    // DEBUG(errs() << "MatchAddress->Disp: " << AM.Disp ;);
    return false;
  }

  case TRICOREISD::Wrapper:
    if (!MatchWrapper(N, AM))
      return false;
    break;

  case ISD::FrameIndex:
    if (AM.BaseType == TriCoreISelAddressMode::RegBase
        && AM.Base.Reg.getNode() == nullptr) {
      AM.BaseType = TriCoreISelAddressMode::FrameIndexBase;
      AM.Base.FrameIndex = cast<FrameIndexSDNode>(N)->getIndex();
      return false;
    }
    break;

  case ISD::ADD: {
    TriCoreISelAddressMode Backup = AM;
    if (!MatchAddress(N.getNode()->getOperand(0), AM) &&
        !MatchAddress(N.getNode()->getOperand(1), AM))
      return false;
    AM = Backup;
    if (!MatchAddress(N.getNode()->getOperand(1), AM) &&
        !MatchAddress(N.getNode()->getOperand(0), AM))
      return false;
    AM = Backup;

    break;
  }

  case ISD::OR:
    // Handle "X | C" as "X + C" iff X is known to have C bits clear.
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
      TriCoreISelAddressMode Backup = AM;
      uint64_t Offset = CN->getSExtValue();
      // Start with the LHS as an addr mode.
      if (!MatchAddress(N.getOperand(0), AM) &&
          // Address could not have picked a GV address for the displacement.
          AM.GV == nullptr &&
          // Check to see if the LHS & C is zero.
          CurDAG->MaskedValueIsZero(N.getOperand(0), CN->getAPIntValue())) {
        AM.Disp += Offset;
        return false;
      }
      AM = Backup;
    }
    break;
  }

  return MatchAddressBase(N, AM);
}

/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.
/// These wrap things that will resolve down into a symbol reference.  If no
/// match is possible, this returns true, otherwise it returns false.
bool TriCoreDAGToDAGISel::MatchWrapper(SDValue N, TriCoreISelAddressMode &AM) {
  // If the addressing mode already has a symbol as the displacement, we can
  // never match another symbol.
  if (AM.hasSymbolicDisplacement()) {
    return true;
  }

  SDValue N0 = N.getOperand(0);

  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(N0)) {
    AM.GV = G->getGlobal();
    AM.Disp += G->getOffset();
  }
  return false;
}

/// MatchAddressBase - Helper for MatchAddress. Add the specified node to the
/// specified addressing mode without any further recursion.
bool TriCoreDAGToDAGISel::MatchAddressBase(SDValue N, TriCoreISelAddressMode &AM) {
  // Is the base register already occupied?
  if (AM.BaseType != TriCoreISelAddressMode::RegBase || AM.Base.Reg.getNode()) {
    // If so, we cannot select it.
    return true;
  }

  // Default, generate it as a register.
  AM.BaseType = TriCoreISelAddressMode::RegBase;
  AM.Base.Reg = N;
  return false;
}